{"version":3,"file":"eventize.js.map","sources":["../src/constants.ts","../src/utils.ts","../src/EventKeeper.ts","../src/EventListener.ts","../src/EventStore.ts","../src/isEventized.ts","../src/priorities.ts","../src/subscribeTo.ts","../src/injectEventizeApi.ts","../src/eventize.ts"],"sourcesContent":["export const EVENT_CATCH_EM_ALL = '*';\n\nexport const LISTENER_UNKNOWN = 0;\nexport const LISTENER_IS_FUNC = 1;\nexport const LISTENER_IS_NAMED_FUNC = 2;\nexport const LISTENER_IS_OBJ = 4;\n\nexport const NAMESPACE: symbol = (() => {\n  // @ts-ignore\n  if (!Symbol.eventize) {\n    // @ts-ignore\n    Symbol.eventize = Symbol('eventize');\n  }\n  // @ts-ignore\n  return Symbol.eventize;\n})();\n\nexport const LOG_NAMESPACE = '[eventize]';\n","/* eslint-disable no-console */\nimport {LOG_NAMESPACE, EVENT_CATCH_EM_ALL} from './constants';\nimport {EventName} from './types';\n\nexport const isCatchEmAll = (eventName: unknown): eventName is string =>\n  eventName === EVENT_CATCH_EM_ALL;\n\nexport const isEventName = (eventName: unknown): eventName is EventName => {\n  switch (typeof eventName) {\n    case 'string':\n    case 'symbol':\n      return true;\n    default:\n      return false;\n  }\n};\n\nexport const hasConsole = typeof console !== 'undefined';\n\nexport const warn = hasConsole\n  ? console[console.warn ? 'warn' : 'log'].bind(console, LOG_NAMESPACE)\n  : () => {};\n\ntype PropertyKey = string | symbol;\ntype PropertyValue = any;\n\nexport const definePublicPropertyRO = <T extends Object>(\n  obj: T,\n  name: PropertyKey,\n  value: PropertyValue,\n): T => {\n  Object.defineProperty(obj, name, {\n    value,\n    configurable: true,\n    enumerable: true,\n  });\n  return obj;\n};\n\nexport const definePublicPropertiesRO = <T extends Object>(\n  obj: T,\n  attrs: Record<PropertyKey, PropertyValue>,\n): T => {\n  const keys = Object.keys(attrs);\n  const len = keys.length;\n  for (let i = 0; i < len; i += 1) {\n    definePublicPropertyRO(obj, keys[i], attrs[keys[i]]);\n  }\n  return obj;\n};\n\nexport const defineHiddenPropertyRO = <T extends Object>(\n  obj: T,\n  name: PropertyKey,\n  value: PropertyValue,\n): T => {\n  Object.defineProperty(obj, name, {\n    value,\n    configurable: true,\n  });\n  return obj;\n};\n","import {AnyEventNames, EventArgs, EventName} from './types';\nimport {isCatchEmAll} from './utils';\n\nexport class EventKeeper {\n  events = new Map<EventName, EventArgs>();\n  eventNames = new Set<EventName>();\n\n  add(eventNames: AnyEventNames): void {\n    if (Array.isArray(eventNames)) {\n      eventNames.forEach((name) => this.eventNames.add(name));\n    } else {\n      this.eventNames.add(eventNames);\n    }\n  }\n\n  remove(eventNames: AnyEventNames): void {\n    if (Array.isArray(eventNames)) {\n      eventNames.forEach((name) => this.eventNames.delete(name));\n    } else {\n      this.eventNames.delete(eventNames);\n    }\n  }\n\n  retain(eventName: EventName, args: EventArgs): void {\n    if (this.eventNames.has(eventName)) {\n      this.events.set(eventName, args);\n    }\n  }\n\n  isKnown(eventName: EventName): boolean {\n    return this.eventNames.has(eventName);\n  }\n\n  emit(\n    eventName: EventName,\n    eventListener: {apply: (eventName: EventName, args?: EventArgs) => void},\n  ): void {\n    if (!isCatchEmAll(eventName)) {\n      const args = this.events.get(eventName);\n      if (args) {\n        eventListener.apply(eventName, args);\n      }\n    } else {\n      this.eventNames.forEach((name) => this.emit(name, eventListener));\n    }\n  }\n}\n","import {\n  EVENT_CATCH_EM_ALL,\n  LISTENER_IS_FUNC,\n  LISTENER_IS_NAMED_FUNC,\n  LISTENER_IS_OBJ,\n} from './constants';\n\nimport {EventName, EventArgs, ListenerObjectType} from './types';\nimport {isCatchEmAll} from './utils';\n\ntype EmitFnType = Function | undefined;\ntype CallAfterApplyFnType = (() => void) | undefined;\n\nconst apply = (context: unknown, func: EmitFnType, args: EventArgs) => {\n  if (typeof func === 'function') {\n    func.apply(context, args);\n  }\n};\n\nconst emit = (\n  eventName: EventName,\n  listener: {emit: EmitFnType},\n  args: EventArgs,\n) => apply(listener, listener.emit, [eventName].concat(args));\n\nconst detectListenerType = (listener: unknown) => {\n  switch (typeof listener) {\n    case 'function':\n      return LISTENER_IS_FUNC;\n    case 'string':\n    case 'symbol':\n      return LISTENER_IS_NAMED_FUNC;\n    case 'object':\n      return LISTENER_IS_OBJ;\n  }\n};\n\nlet lastId = 0;\nconst createUniqId = () => ++lastId;\n\nexport class EventListener {\n  readonly id: number;\n  readonly eventName: EventName;\n  readonly isCatchEmAll: boolean;\n  readonly priority: number | undefined;\n  readonly listener: unknown;\n  readonly listenerObject: ListenerObjectType;\n  readonly listenerType: number;\n  callAfterApply: CallAfterApplyFnType;\n  isRemoved: boolean;\n\n  constructor(\n    eventName: EventName,\n    priority: number | undefined,\n    listener: unknown,\n    listenerObject: ListenerObjectType = null,\n  ) {\n    this.id = createUniqId();\n    this.eventName = eventName;\n    this.isCatchEmAll = isCatchEmAll(eventName);\n    this.listener = listener;\n    this.listenerObject = listenerObject;\n    this.priority = priority;\n    this.listenerType = detectListenerType(listener);\n    this.callAfterApply = undefined;\n    this.isRemoved = false;\n  }\n\n  isEqual(\n    listener: unknown,\n    listenerObject: ListenerObjectType = null,\n  ): boolean {\n    if (listener === this) return true;\n    const typeofListener = typeof listener;\n    if (typeofListener === 'number' && listener === this.id) return true;\n    if (\n      listenerObject === null &&\n      (typeofListener === 'string' || typeofListener === 'symbol')\n    ) {\n      if (listener === EVENT_CATCH_EM_ALL) return true;\n      if (listener === this.eventName) return true;\n      return false;\n    }\n    return this.listener === listener && this.listenerObject === listenerObject;\n  }\n\n  apply(eventName: EventName, args?: EventArgs): void {\n    if (this.isRemoved) return;\n\n    const {listener, listenerObject} = this;\n\n    switch (this.listenerType) {\n      case LISTENER_IS_FUNC:\n        // @ts-ignore\n        apply(listenerObject, listener, args);\n        if (this.callAfterApply) this.callAfterApply();\n        break;\n\n      case LISTENER_IS_NAMED_FUNC:\n        // @ts-ignore\n        apply(listenerObject, listenerObject[listener], args);\n        if (this.callAfterApply) this.callAfterApply();\n        break;\n\n      case LISTENER_IS_OBJ: {\n        // @ts-ignore\n        const func = listener[eventName];\n        if (this.isCatchEmAll || this.eventName === eventName) {\n          if (typeof func === 'function') {\n            func.apply(listener, args);\n          } else {\n            // @ts-ignore\n            emit(eventName, listener, args);\n          }\n          if (this.callAfterApply) this.callAfterApply();\n        }\n        break;\n      }\n    }\n  }\n}\n","import {EventListener} from './EventListener';\nimport {EVENT_CATCH_EM_ALL} from './constants';\nimport {EventName, ListenerObjectType} from './types';\nimport {isCatchEmAll, isEventName} from './utils';\n\ntype HasPriorityOrIdType = {priority: number; id: number};\n\nconst sortByPrioAndId = (\n  a: HasPriorityOrIdType,\n  b: HasPriorityOrIdType,\n): number =>\n  a.priority !== b.priority ? b.priority - a.priority : a.id - b.id;\n\nconst cloneArray = <T>(arr: Array<T>): Array<T> => arr?.slice(0);\n\nconst removeListenerItem = (arr: Array<any>, listener: any) => {\n  const idx = arr.indexOf(listener);\n  if (idx > -1) {\n    arr.splice(idx, 1);\n  }\n};\n\nconst removeListener = (\n  listeners: Array<EventListener>,\n  listener: unknown,\n  listenerObject: ListenerObjectType,\n) => {\n  const idx = listeners.findIndex((item) =>\n    item.isEqual(listener, listenerObject),\n  );\n  if (idx > -1) {\n    listeners[idx].isRemoved = true;\n    listeners.splice(idx, 1);\n  }\n};\n\nconst removeAllListeners = (listeners: Array<EventListener>) => {\n  if (listeners) {\n    listeners.forEach((li) => {\n      li.isRemoved = true;\n    });\n    listeners.length = 0;\n  }\n};\n\nexport class EventStore {\n  readonly namedListeners: Map<EventName, Array<EventListener>>;\n  readonly catchEmAllListeners: Array<EventListener>;\n\n  constructor() {\n    this.namedListeners = new Map();\n    this.catchEmAllListeners = [];\n  }\n\n  add(eventListener: EventListener): void {\n    if (eventListener.isCatchEmAll) {\n      this.catchEmAllListeners.push(eventListener);\n      this.catchEmAllListeners.sort(sortByPrioAndId);\n    } else {\n      const {eventName} = eventListener;\n      let namedListeners = this.namedListeners.get(eventName);\n      if (!namedListeners) {\n        namedListeners = [];\n        this.namedListeners.set(eventName, namedListeners);\n      }\n      namedListeners.push(eventListener);\n      namedListeners.sort(sortByPrioAndId);\n    }\n  }\n\n  remove(listener: unknown, listenerObject: ListenerObjectType): void {\n    if (listenerObject == null && Array.isArray(listener)) {\n      listener.forEach(this.remove.bind(this));\n    } else if (\n      listener == null ||\n      (listenerObject == null && isCatchEmAll(listener))\n    ) {\n      this.removeAllListeners();\n    } else if (listenerObject == null && isEventName(listener)) {\n      const listeners = this.namedListeners.get(listener);\n      removeAllListeners(listeners);\n    } else if (listener instanceof EventListener) {\n      listener.isRemoved = true;\n      this.namedListeners.forEach((namedListeners) =>\n        removeListenerItem(namedListeners, listener),\n      );\n      removeListenerItem(this.catchEmAllListeners, listener);\n    } else {\n      this.namedListeners.forEach((namedListeners) =>\n        removeListener(namedListeners, listener, listenerObject),\n      );\n      removeListener(this.catchEmAllListeners, listener, listenerObject);\n    }\n  }\n\n  removeAllListeners(): void {\n    this.namedListeners.forEach((namedListeners) =>\n      removeAllListeners(namedListeners),\n    );\n    this.namedListeners.clear();\n    removeAllListeners(this.catchEmAllListeners);\n  }\n\n  forEach(eventName: EventName, fn: (listener: EventListener) => void): void {\n    const catchEmAllListeners = cloneArray(this.catchEmAllListeners);\n    const namedListeners = cloneArray(this.namedListeners.get(eventName));\n    if (\n      eventName === EVENT_CATCH_EM_ALL ||\n      !namedListeners ||\n      namedListeners.length === 0\n    ) {\n      catchEmAllListeners.forEach(fn);\n    } else if (catchEmAllListeners.length === 0) {\n      namedListeners.forEach(fn);\n    } else {\n      const iLen = namedListeners.length;\n      const jLen = catchEmAllListeners.length;\n      let i = 0;\n      let j = 0;\n      while (i < iLen || j < jLen) {\n        if (i < iLen) {\n          const cur = namedListeners[i];\n          if (j >= jLen || cur.priority >= catchEmAllListeners[j].priority) {\n            fn(cur);\n            ++i;\n            continue;\n          }\n        }\n        if (j < jLen) {\n          fn(catchEmAllListeners[j]);\n          ++j;\n        }\n      }\n    }\n  }\n}\n","import {NAMESPACE} from './constants';\nimport {EventizeApi} from './types';\n\nexport const isEventized = <T extends Object>(obj: T): obj is T & EventizeApi =>\n  !!(\n    obj &&\n    // @ts-ignore\n    obj[NAMESPACE]\n  );\n\nexport type EventizeGuard = typeof isEventized;\n","export const PRIO_MAX = Number.POSITIVE_INFINITY;\nexport const PRIO_A = 1000000000;\nexport const PRIO_B = 1000000;\nexport const PRIO_C = 1000;\nexport const PRIO_DEFAULT = 0;\nexport const PRIO_LOW = -10000;\nexport const PRIO_MIN = Number.NEGATIVE_INFINITY;\n","import {EventKeeper} from './EventKeeper';\nimport {EventListener} from './EventListener';\nimport {EventStore} from './EventStore';\nimport {EVENT_CATCH_EM_ALL} from './constants';\nimport {PRIO_DEFAULT} from './priorities';\nimport {EventArgs, EventName, ListenerObjectType} from './types';\nimport {hasConsole, warn} from './utils';\n\nconst registerEventListener = (\n  store: EventStore,\n  keeper: EventKeeper,\n  eventName: EventName,\n  priority: number,\n  listener: unknown,\n  listenerObject: ListenerObjectType,\n): EventListener => {\n  const eventListener = new EventListener(\n    eventName,\n    priority,\n    listener,\n    listenerObject,\n  );\n  store.add(eventListener);\n  keeper.emit(eventName, eventListener);\n  return eventListener;\n};\n\nexport const subscribeTo = (\n  store: EventStore,\n  keeper: EventKeeper,\n  args: EventArgs,\n): EventListener | Array<EventListener> => {\n  const len = args.length;\n  const typeOfFirstArg = typeof args[0];\n\n  let eventName: EventName;\n  let priority: number;\n  let listener: unknown;\n  let listenerObject: ListenerObjectType;\n\n  if (len >= 2 && len <= 3 && typeOfFirstArg === 'number') {\n    eventName = EVENT_CATCH_EM_ALL;\n    [priority, listener, listenerObject] = args;\n  } else if (len >= 3 && len <= 4 && typeof args[1] === 'number') {\n    [eventName, priority, listener, listenerObject] = args;\n  } else {\n    priority = PRIO_DEFAULT;\n    if (\n      typeOfFirstArg === 'string' ||\n      typeOfFirstArg === 'symbol' ||\n      Array.isArray(args[0])\n    ) {\n      [eventName, listener, listenerObject] = args;\n    } else {\n      eventName = EVENT_CATCH_EM_ALL;\n      [listener, listenerObject] = args;\n    }\n  }\n\n  if (!listener && hasConsole) {\n    warn('called with insufficient arguments!', args);\n    throw 'subscribeTo called with insufficient arguments!';\n  }\n\n  const register = (prio: number) => (event: EventName) =>\n    registerEventListener(store, keeper, event, prio, listener, listenerObject);\n\n  if (Array.isArray(eventName)) {\n    return eventName.map((name) => {\n      if (Array.isArray(name)) {\n        return register(name[1])(name[0]);\n      }\n      return register(priority)(name);\n    });\n  }\n  return register(priority)(eventName);\n};\n","import {EventKeeper} from './EventKeeper';\nimport {EventListener} from './EventListener';\nimport {EventStore} from './EventStore';\nimport {EVENT_CATCH_EM_ALL, NAMESPACE} from './constants';\nimport {isEventized} from './isEventized';\nimport {subscribeTo} from './subscribeTo';\nimport {\n  AnyEventNames,\n  EventArgs,\n  EventizeApi,\n  EventName,\n  ListenerType,\n  ListenerObjectType,\n  SubscribeArgs,\n  UnsubscribeFunc,\n} from './types';\nimport {defineHiddenPropertyRO, isEventName} from './utils';\n\nconst unsubscribeAfterApply = (obj: EventizeApi) => (\n  listener: EventListener,\n) => {\n  listener.callAfterApply = () => obj.off(listener);\n};\n\nconst makeUnsubscribe = (\n  host: EventizeApi,\n  listeners: EventListener | Array<EventListener>,\n): UnsubscribeFunc => {\n  const unsubscribe = () => host.off(listeners);\n  return Object.assign(\n    unsubscribe,\n    Array.isArray(listeners) ? {listeners} : {listener: listeners},\n  ) as UnsubscribeFunc;\n};\n\nexport function injectEventizeApi<T extends Object>(obj: T): T & EventizeApi {\n  if (isEventized(obj)) {\n    // it already has the interface - no need to inject it again\n    return obj;\n  }\n\n  const store = new EventStore();\n  const keeper = new EventKeeper();\n\n  defineHiddenPropertyRO(obj, NAMESPACE, {keeper, store});\n\n  const eventizedObj = Object.assign(obj, {\n    on(...args: SubscribeArgs): UnsubscribeFunc {\n      return makeUnsubscribe(eventizedObj, subscribeTo(store, keeper, args));\n    },\n\n    once(...args: SubscribeArgs): UnsubscribeFunc {\n      const listeners = subscribeTo(store, keeper, args);\n      if (Array.isArray(listeners)) {\n        listeners.forEach(unsubscribeAfterApply(eventizedObj));\n      } else {\n        unsubscribeAfterApply(eventizedObj)(listeners);\n      }\n      return makeUnsubscribe(eventizedObj, listeners);\n    },\n\n    off(listener?: ListenerType, listenerObject?: ListenerObjectType): void {\n      store.remove(listener, listenerObject);\n      if (Array.isArray(listener)) {\n        keeper.remove(listener.filter((li) => typeof li === 'string'));\n      } else if (isEventName(listener)) {\n        keeper.remove(listener);\n      }\n    },\n\n    emit(eventNames: AnyEventNames, ...args: EventArgs): void {\n      if (Array.isArray(eventNames)) {\n        eventNames.forEach((event: EventName) => {\n          store.forEach(event, (listener) => listener.apply(event, args));\n          keeper.retain(event, args);\n        });\n      } else if (eventNames !== EVENT_CATCH_EM_ALL) {\n        store.forEach(eventNames, (listener) => {\n          listener.apply(eventNames, args);\n        });\n        keeper.retain(eventNames, args);\n      }\n    },\n\n    retain(eventName: EventName): void {\n      keeper.add(eventName);\n    },\n  });\n\n  return eventizedObj;\n}\n","import {EVENT_CATCH_EM_ALL} from './constants';\nimport {injectEventizeApi} from './injectEventizeApi';\nimport {isEventized, EventizeGuard} from './isEventized';\nimport {\n  PRIO_A,\n  PRIO_B,\n  PRIO_C,\n  PRIO_DEFAULT,\n  PRIO_LOW,\n  PRIO_MAX,\n  PRIO_MIN,\n} from './priorities';\nimport {EventizeApi} from './types';\n\nfunction eventize<T extends Object>(obj: T): T & EventizeApi {\n  return injectEventizeApi(obj);\n}\n\neventize.inject = injectEventizeApi;\n\neventize.extend = <T extends Object>(obj: T): T & EventizeApi =>\n  injectEventizeApi(Object.create(obj));\n\neventize.create = (obj: Object): EventizeApi => {\n  const eventizer = injectEventizeApi({});\n  eventizer.on(EVENT_CATCH_EM_ALL, PRIO_DEFAULT, obj);\n  return eventizer;\n};\n\neventize.is = isEventized;\n\nObject.assign(eventize, {\n  PRIO_MAX,\n  PRIO_A,\n  PRIO_B,\n  PRIO_C,\n  PRIO_DEFAULT,\n  PRIO_LOW,\n  PRIO_MIN,\n});\n\nexport interface EventizerFunc {\n  <T extends Object>(obj: T): T & EventizeApi;\n}\n\nexport interface EventizeFuncApi extends EventizerFunc {\n  inject: EventizerFunc;\n  extend: EventizerFunc;\n  create(obj: Object): EventizeApi;\n\n  is: EventizeGuard;\n\n  PRIO_MAX: number;\n  PRIO_A: number;\n  PRIO_B: number;\n  PRIO_C: number;\n  PRIO_DEFAULT: number;\n  PRIO_LOW: number;\n  PRIO_MIN: number;\n}\n\nconst eventizedFuncApi = eventize as EventizeFuncApi;\nexport {eventizedFuncApi as eventize};\n\nexport interface Eventize extends EventizeApi {}\n\nexport class Eventize {\n  constructor() {\n    eventize(this);\n  }\n}\n"],"names":["NAMESPACE","Symbol","eventize","isCatchEmAll","eventName","isEventName","hasConsole","console","warn","bind","EventKeeper","[object Object]","this","Map","Set","eventNames","Array","isArray","forEach","name","add","delete","args","has","events","set","eventListener","emit","get","apply","context","func","lastId","EventListener","priority","listener","listenerObject","id","listenerType","detectListenerType","callAfterApply","undefined","isRemoved","typeofListener","concat","sortByPrioAndId","a","b","cloneArray","arr","slice","removeListenerItem","idx","indexOf","splice","removeListener","listeners","findIndex","item","isEqual","removeAllListeners","li","length","EventStore","namedListeners","catchEmAllListeners","push","sort","remove","clear","fn","iLen","jLen","i","j","cur","isEventized","obj","PRIO_MAX","Number","POSITIVE_INFINITY","PRIO_A","PRIO_B","PRIO_C","PRIO_DEFAULT","PRIO_LOW","PRIO_MIN","NEGATIVE_INFINITY","subscribeTo","store","keeper","len","typeOfFirstArg","register","prio","event","registerEventListener","map","unsubscribeAfterApply","off","makeUnsubscribe","host","Object","assign","injectEventizeApi","value","defineProperty","configurable","defineHiddenPropertyRO","eventizedObj","on","filter","retain","inject","extend","create","eventizer","is","eventizedFuncApi","Eventize"],"mappings":"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"}