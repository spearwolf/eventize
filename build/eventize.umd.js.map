{"version":3,"file":"eventize.umd.js.map","sources":["../src/constants.ts","../src/utils.ts","../src/EventKeeper.ts","../src/EventListener.ts","../src/EventStore.ts","../src/isEventized.ts","../src/subscribeTo.ts","../src/injectEventizeApi.ts","../src/eventize.ts"],"sourcesContent":["export const EVENT_CATCH_EM_ALL = '*';\n\nexport const LISTENER_UNKNOWN = 0;\nexport const LISTENER_IS_FUNC = 1;\nexport const LISTENER_IS_NAMED_FUNC = 2;\nexport const LISTENER_IS_OBJ = 4;\n\nexport const PRIO_MAX = Number.POSITIVE_INFINITY;\nexport const PRIO_A = 1000000000;\nexport const PRIO_B = 1000000;\nexport const PRIO_C = 1000;\nexport const PRIO_DEFAULT = 0;\nexport const PRIO_LOW = -10000;\nexport const PRIO_MIN = Number.NEGATIVE_INFINITY;\n\nexport const NAMESPACE: symbol = (() => {\n  // @ts-ignore\n  if (!Symbol.eventize) {\n    // @ts-ignore\n    Symbol.eventize = Symbol('eventize');\n  }\n  // @ts-ignore\n  return Symbol.eventize;\n})();\n\nexport const LOG_NAMESPACE = '[eventize]';\n","/* eslint-disable no-console */\nimport {LOG_NAMESPACE, EVENT_CATCH_EM_ALL} from './constants';\nimport {EventName} from './types';\n\nexport const isCatchEmAll = (eventName: unknown): eventName is string =>\n  eventName === EVENT_CATCH_EM_ALL;\n\nexport const isEventName = (eventName: unknown): eventName is EventName => {\n  switch (typeof eventName) {\n    case 'string':\n    case 'symbol':\n      return true;\n    default:\n      return false;\n  }\n};\n\nexport const hasConsole = typeof console !== 'undefined';\n\nexport const warn = hasConsole\n  ? console[console.warn ? 'warn' : 'log'].bind(console, LOG_NAMESPACE)\n  : () => {};\n\ntype PropertyKey = string | symbol;\ntype PropertyValue = any;\n\nexport const definePublicPropertyRO = <T extends Object>(\n  obj: T,\n  name: PropertyKey,\n  value: PropertyValue,\n): T => {\n  Object.defineProperty(obj, name, {\n    value,\n    configurable: true,\n    enumerable: true,\n  });\n  return obj;\n};\n\nexport const definePublicPropertiesRO = <T extends Object>(\n  obj: T,\n  attrs: Record<PropertyKey, PropertyValue>,\n): T => {\n  const keys = Object.keys(attrs);\n  const len = keys.length;\n  for (let i = 0; i < len; i += 1) {\n    definePublicPropertyRO(obj, keys[i], attrs[keys[i]]);\n  }\n  return obj;\n};\n\nexport const defineHiddenPropertyRO = <T extends Object>(\n  obj: T,\n  name: PropertyKey,\n  value: PropertyValue,\n): T => {\n  Object.defineProperty(obj, name, {\n    value,\n    configurable: true,\n  });\n  return obj;\n};\n","import {AnyEventNames, EventArgs, EventName} from './types';\nimport {isCatchEmAll} from './utils';\n\nexport class EventKeeper {\n  events = new Map<EventName, EventArgs>();\n  eventNames = new Set<EventName>();\n\n  add(eventNames: AnyEventNames): void {\n    if (Array.isArray(eventNames)) {\n      eventNames.forEach((name) => this.eventNames.add(name));\n    } else {\n      this.eventNames.add(eventNames);\n    }\n  }\n\n  remove(eventNames: AnyEventNames): void {\n    if (Array.isArray(eventNames)) {\n      eventNames.forEach((name) => this.eventNames.delete(name));\n    } else {\n      this.eventNames.delete(eventNames);\n    }\n  }\n\n  retain(eventName: EventName, args: EventArgs): void {\n    if (this.eventNames.has(eventName)) {\n      this.events.set(eventName, args);\n    }\n  }\n\n  isKnown(eventName: EventName): boolean {\n    return this.eventNames.has(eventName);\n  }\n\n  emit(\n    eventName: EventName,\n    eventListener: {apply: (eventName: EventName, args?: EventArgs) => void},\n  ): void {\n    if (!isCatchEmAll(eventName)) {\n      const args = this.events.get(eventName);\n      if (args) {\n        eventListener.apply(eventName, args);\n      }\n    } else {\n      this.eventNames.forEach((name) => this.emit(name, eventListener));\n    }\n  }\n}\n","import {\n  EVENT_CATCH_EM_ALL,\n  LISTENER_IS_FUNC,\n  LISTENER_IS_NAMED_FUNC,\n  LISTENER_IS_OBJ,\n} from './constants';\n\nimport {EventName, EventArgs, ListenerObjectType} from './types';\nimport {isCatchEmAll, isEventName} from './utils';\n\ntype EmitFnType = Function | undefined;\ntype CallAfterApplyFnType = (() => void) | undefined;\n\nconst apply = (context: unknown, func: EmitFnType, args: EventArgs) => {\n  if (typeof func === 'function') {\n    func.apply(context, args);\n  }\n};\n\nconst emit = (\n  eventName: EventName,\n  listener: {emit: EmitFnType},\n  args: EventArgs,\n) => apply(listener, listener.emit, [eventName].concat(args));\n\nconst detectListenerType = (listener: unknown) => {\n  switch (typeof listener) {\n    case 'function':\n      return LISTENER_IS_FUNC;\n    case 'string':\n    case 'symbol':\n      return LISTENER_IS_NAMED_FUNC;\n    case 'object':\n      return LISTENER_IS_OBJ;\n  }\n};\n\nlet lastId = 0;\nconst createUniqId = () => ++lastId;\n\nexport class EventListener {\n  readonly id: number;\n  readonly eventName: EventName;\n  readonly isCatchEmAll: boolean;\n  readonly priority: number | undefined;\n  readonly listener: unknown;\n  readonly listenerObject: ListenerObjectType;\n  readonly listenerType: number;\n  callAfterApply: CallAfterApplyFnType;\n  isRemoved: boolean;\n\n  constructor(\n    eventName: EventName,\n    priority: number | undefined,\n    listener: unknown,\n    listenerObject: ListenerObjectType = null,\n  ) {\n    this.id = createUniqId();\n    this.eventName = eventName;\n    this.isCatchEmAll = isCatchEmAll(eventName);\n    this.listener = listener;\n    this.listenerObject = listenerObject;\n    this.priority = priority;\n    this.listenerType = detectListenerType(listener);\n    this.callAfterApply = undefined;\n    this.isRemoved = false;\n  }\n\n  isEqual(\n    listener: unknown,\n    listenerObject: ListenerObjectType = null,\n  ): boolean {\n    if (listener === this) return true;\n    if (typeof listener === 'number' && listener === this.id) return true;\n    if (listenerObject === null && isEventName(listener)) {\n      if (listener === EVENT_CATCH_EM_ALL) return true;\n      if (listener === this.eventName) return true;\n      return false;\n    }\n    return this.listener === listener && this.listenerObject === listenerObject;\n  }\n\n  apply(eventName: EventName, args?: EventArgs): void {\n    if (this.isRemoved) return;\n\n    const {listener, listenerObject} = this;\n\n    switch (this.listenerType) {\n      case LISTENER_IS_FUNC:\n        // @ts-ignore\n        apply(listenerObject, listener, args);\n        if (this.callAfterApply) this.callAfterApply();\n        break;\n\n      case LISTENER_IS_NAMED_FUNC:\n        // @ts-ignore\n        apply(listenerObject, listenerObject[listener], args);\n        if (this.callAfterApply) this.callAfterApply();\n        break;\n\n      case LISTENER_IS_OBJ: {\n        // @ts-ignore\n        const func = listener[eventName];\n        if (this.isCatchEmAll || this.eventName === eventName) {\n          if (typeof func === 'function') {\n            func.apply(listener, args);\n          } else {\n            // @ts-ignore\n            emit(eventName, listener, args);\n          }\n          if (this.callAfterApply) this.callAfterApply();\n        }\n        break;\n      }\n    }\n  }\n}\n","import {EventListener} from './EventListener';\nimport {EVENT_CATCH_EM_ALL} from './constants';\nimport {EventName, ListenerObjectType} from './types';\nimport {isCatchEmAll, isEventName} from './utils';\n\ntype HasPriorityOrIdType = {priority: number; id: number};\n\nconst sortByPrioAndId = (\n  a: HasPriorityOrIdType,\n  b: HasPriorityOrIdType,\n): number =>\n  a.priority !== b.priority ? b.priority - a.priority : a.id - b.id;\n\nconst cloneArray = <T>(arr: Array<T>): Array<T> => arr?.slice(0);\n\nconst removeListenerItem = (arr: Array<any>, listener: any) => {\n  const idx = arr.indexOf(listener);\n  if (idx > -1) {\n    arr.splice(idx, 1);\n  }\n};\n\nconst removeListener = (\n  listeners: Array<EventListener>,\n  listener: unknown,\n  listenerObject: ListenerObjectType,\n) => {\n  const idx = listeners.findIndex((item) =>\n    item.isEqual(listener, listenerObject),\n  );\n  if (idx > -1) {\n    listeners[idx].isRemoved = true;\n    listeners.splice(idx, 1);\n  }\n};\n\nconst removeAllListeners = (listeners: Array<EventListener>) => {\n  if (listeners) {\n    listeners.forEach((li) => {\n      li.isRemoved = true;\n    });\n    listeners.length = 0;\n  }\n};\n\nexport class EventStore {\n  readonly namedListeners: Map<EventName, Array<EventListener>>;\n  readonly catchEmAllListeners: Array<EventListener>;\n\n  constructor() {\n    this.namedListeners = new Map();\n    this.catchEmAllListeners = [];\n  }\n\n  add(eventListener: EventListener): void {\n    if (eventListener.isCatchEmAll) {\n      this.catchEmAllListeners.push(eventListener);\n      this.catchEmAllListeners.sort(sortByPrioAndId);\n    } else {\n      const {eventName} = eventListener;\n      let namedListeners = this.namedListeners.get(eventName);\n      if (!namedListeners) {\n        namedListeners = [];\n        this.namedListeners.set(eventName, namedListeners);\n      }\n      namedListeners.push(eventListener);\n      namedListeners.sort(sortByPrioAndId);\n    }\n  }\n\n  remove(listener: unknown, listenerObject: ListenerObjectType): void {\n    if (listenerObject == null && Array.isArray(listener)) {\n      listener.forEach(this.remove.bind(this));\n    } else if (\n      listener == null ||\n      (listenerObject == null && isCatchEmAll(listener))\n    ) {\n      this.removeAllListeners();\n    } else if (listenerObject == null && isEventName(listener)) {\n      const listeners = this.namedListeners.get(listener);\n      removeAllListeners(listeners);\n    } else if (listener instanceof EventListener) {\n      listener.isRemoved = true;\n      this.namedListeners.forEach((namedListeners) =>\n        removeListenerItem(namedListeners, listener),\n      );\n      removeListenerItem(this.catchEmAllListeners, listener);\n    } else {\n      this.namedListeners.forEach((namedListeners) =>\n        removeListener(namedListeners, listener, listenerObject),\n      );\n      removeListener(this.catchEmAllListeners, listener, listenerObject);\n    }\n  }\n\n  removeAllListeners(): void {\n    this.namedListeners.forEach((namedListeners) =>\n      removeAllListeners(namedListeners),\n    );\n    this.namedListeners.clear();\n    removeAllListeners(this.catchEmAllListeners);\n  }\n\n  forEach(eventName: EventName, fn: (listener: EventListener) => void): void {\n    const catchEmAllListeners = cloneArray(this.catchEmAllListeners);\n    const namedListeners = cloneArray(this.namedListeners.get(eventName));\n    if (\n      eventName === EVENT_CATCH_EM_ALL ||\n      !namedListeners ||\n      namedListeners.length === 0\n    ) {\n      catchEmAllListeners.forEach(fn);\n    } else if (catchEmAllListeners.length === 0) {\n      namedListeners.forEach(fn);\n    } else {\n      const iLen = namedListeners.length;\n      const jLen = catchEmAllListeners.length;\n      let i = 0;\n      let j = 0;\n      while (i < iLen || j < jLen) {\n        if (i < iLen) {\n          const cur = namedListeners[i];\n          if (j >= jLen || cur.priority >= catchEmAllListeners[j].priority) {\n            fn(cur);\n            ++i;\n            continue;\n          }\n        }\n        if (j < jLen) {\n          fn(catchEmAllListeners[j]);\n          ++j;\n        }\n      }\n    }\n  }\n}\n","import {NAMESPACE} from './constants';\nimport {EventizeApi} from './types';\n\nexport const isEventized = <T extends Object>(obj: T): obj is T & EventizeApi =>\n  !!(\n    obj &&\n    // @ts-ignore\n    obj[NAMESPACE]\n  );\n\nexport type EventizeGuard = typeof isEventized;\n","import {EventKeeper} from './EventKeeper';\nimport {EventListener} from './EventListener';\nimport {EventStore} from './EventStore';\nimport {EVENT_CATCH_EM_ALL, PRIO_DEFAULT} from './constants';\nimport {EventArgs, EventName, ListenerObjectType} from './types';\nimport {hasConsole, isEventName, warn} from './utils';\n\nconst registerEventListener = (\n  store: EventStore,\n  keeper: EventKeeper,\n  eventName: EventName,\n  priority: number,\n  listener: unknown,\n  listenerObject: ListenerObjectType,\n): EventListener => {\n  const eventListener = new EventListener(\n    eventName,\n    priority,\n    listener,\n    listenerObject,\n  );\n  store.add(eventListener);\n  keeper.emit(eventName, eventListener);\n  return eventListener;\n};\n\nexport const subscribeTo = (\n  store: EventStore,\n  keeper: EventKeeper,\n  args: EventArgs,\n): EventListener | Array<EventListener> => {\n  const len = args.length;\n  const typeOfFirstArg = typeof args[0];\n\n  let eventName: EventName;\n  let priority: number;\n  let listener: unknown;\n  let listenerObject: ListenerObjectType;\n\n  if (len >= 2 && len <= 3 && typeOfFirstArg === 'number') {\n    eventName = EVENT_CATCH_EM_ALL;\n    [priority, listener, listenerObject] = args;\n  } else if (len >= 3 && len <= 4 && typeof args[1] === 'number') {\n    [eventName, priority, listener, listenerObject] = args;\n  } else {\n    priority = PRIO_DEFAULT;\n    if (isEventName(typeOfFirstArg) || Array.isArray(args[0])) {\n      [eventName, listener, listenerObject] = args;\n    } else {\n      eventName = EVENT_CATCH_EM_ALL;\n      [listener, listenerObject] = args;\n    }\n  }\n\n  if (!listener && hasConsole) {\n    warn('called with insufficient arguments!', args);\n    throw 'subscribeTo called with insufficient arguments!';\n  }\n\n  const register = (prio: number) => (event: EventName) =>\n    registerEventListener(store, keeper, event, prio, listener, listenerObject);\n\n  if (Array.isArray(eventName)) {\n    return eventName.map((name) => {\n      if (Array.isArray(name)) {\n        return register(name[1])(name[0]);\n      }\n      return register(priority)(name);\n    });\n  }\n  return register(priority)(eventName);\n};\n","import {EventKeeper} from './EventKeeper';\nimport {EventListener} from './EventListener';\nimport {EventStore} from './EventStore';\nimport {EVENT_CATCH_EM_ALL, NAMESPACE} from './constants';\nimport {isEventized} from './isEventized';\nimport {subscribeTo} from './subscribeTo';\nimport {\n  AnyEventNames,\n  EventArgs,\n  EventizeApi,\n  EventName,\n  ListenerType,\n  ListenerObjectType,\n  SubscribeArgs,\n  UnsubscribeFunc,\n} from './types';\nimport {defineHiddenPropertyRO, isEventName} from './utils';\n\nconst unsubscribeAfterApply = (obj: EventizeApi) => (\n  listener: EventListener,\n) => {\n  listener.callAfterApply = () => obj.off(listener);\n};\n\nconst makeUnsubscribe = (\n  host: EventizeApi,\n  listeners: EventListener | Array<EventListener>,\n): UnsubscribeFunc => {\n  const unsubscribe = () => host.off(listeners);\n  return Object.assign(\n    unsubscribe,\n    Array.isArray(listeners) ? {listeners} : {listener: listeners},\n  ) as UnsubscribeFunc;\n};\n\nexport function injectEventizeApi<T extends Object>(obj: T): T & EventizeApi {\n  if (isEventized(obj)) {\n    // it already has the interface - no need to inject it again\n    return obj;\n  }\n\n  const store = new EventStore();\n  const keeper = new EventKeeper();\n\n  defineHiddenPropertyRO(obj, NAMESPACE, {keeper, store});\n\n  const eventizedObj = Object.assign(obj, {\n    on(...args: SubscribeArgs): UnsubscribeFunc {\n      return makeUnsubscribe(eventizedObj, subscribeTo(store, keeper, args));\n    },\n\n    once(...args: SubscribeArgs): UnsubscribeFunc {\n      const listeners = subscribeTo(store, keeper, args);\n      if (Array.isArray(listeners)) {\n        listeners.forEach(unsubscribeAfterApply(eventizedObj));\n      } else {\n        unsubscribeAfterApply(eventizedObj)(listeners);\n      }\n      return makeUnsubscribe(eventizedObj, listeners);\n    },\n\n    off(listener: ListenerType, listenerObject?: ListenerObjectType): void {\n      store.remove(listener, listenerObject);\n      if (Array.isArray(listener)) {\n        keeper.remove(listener.filter((li) => typeof li === 'string'));\n      } else if (isEventName(listener)) {\n        keeper.remove(listener);\n      }\n    },\n\n    emit(eventNames: AnyEventNames, ...args: EventArgs): void {\n      if (Array.isArray(eventNames)) {\n        eventNames.forEach((event) => {\n          store.forEach(event, (listener) => listener.apply(event, args));\n          keeper.retain(event, args);\n        });\n      } else if (eventNames !== EVENT_CATCH_EM_ALL) {\n        store.forEach(eventNames, (listener) =>\n          listener.apply(eventNames, args),\n        );\n        keeper.retain(eventNames, args);\n      }\n    },\n\n    retain(eventName: EventName): void {\n      keeper.add(eventName);\n    },\n  });\n\n  return eventizedObj;\n}\n","import {\n  EVENT_CATCH_EM_ALL,\n  PRIO_A,\n  PRIO_B,\n  PRIO_C,\n  PRIO_DEFAULT,\n  PRIO_LOW,\n  PRIO_MAX,\n  PRIO_MIN,\n} from './constants';\nimport {injectEventizeApi} from './injectEventizeApi';\nimport {isEventized, EventizeGuard} from './isEventized';\nimport {EventizeApi} from './types';\n\nfunction eventize<T extends Object>(obj: T): T & EventizeApi {\n  return injectEventizeApi(obj);\n}\n\neventize.inject = injectEventizeApi;\n\neventize.extend = <T extends Object>(obj: T): T & EventizeApi =>\n  injectEventizeApi(Object.create(obj));\n\neventize.create = (obj: Object): EventizeApi => {\n  const eventizer = injectEventizeApi({});\n  eventizer.on(EVENT_CATCH_EM_ALL, PRIO_DEFAULT, obj);\n  return eventizer;\n};\n\neventize.is = isEventized;\n\nObject.assign(eventize, {\n  PRIO_MAX,\n  PRIO_A,\n  PRIO_B,\n  PRIO_C,\n  PRIO_DEFAULT,\n  PRIO_LOW,\n  PRIO_MIN,\n});\n\nexport interface EventizerFunc {\n  <T extends Object>(obj: T): T & EventizeApi;\n}\n\nexport interface EventizeFuncApi extends EventizerFunc {\n  inject: EventizerFunc;\n  extend: EventizerFunc;\n  create(obj: Object): EventizeApi;\n  is: EventizeGuard;\n  PRIO_MAX: number;\n  PRIO_A: number;\n  PRIO_B: number;\n  PRIO_C: number;\n  PRIO_DEFAULT: number;\n  PRIO_LOW: number;\n  PRIO_MIN: number;\n}\n\nexport default eventize as EventizeFuncApi;\n\nexport interface Eventize extends EventizeApi {}\n\nexport class Eventize {\n  constructor() {\n    eventize(this);\n  }\n}\n"],"names":["EVENT_CATCH_EM_ALL","PRIO_MAX","Number","POSITIVE_INFINITY","PRIO_A","PRIO_B","PRIO_LOW","PRIO_MIN","NEGATIVE_INFINITY","NAMESPACE","Symbol","eventize","LOG_NAMESPACE","isCatchEmAll","eventName","isEventName","hasConsole","console","warn","bind","EventKeeper","[object Object]","this","Map","Set","eventNames","Array","isArray","forEach","name","add","delete","args","has","events","set","eventListener","emit","get","apply","context","func","lastId","EventListener","priority","listener","listenerObject","id","listenerType","detectListenerType","callAfterApply","undefined","isRemoved","concat","sortByPrioAndId","a","b","cloneArray","arr","slice","removeListenerItem","idx","indexOf","splice","removeListener","listeners","findIndex","item","isEqual","removeAllListeners","li","length","EventStore","namedListeners","catchEmAllListeners","push","sort","remove","clear","fn","iLen","jLen","i","j","cur","isEventized","obj","subscribeTo","store","keeper","len","typeOfFirstArg","register","prio","event","registerEventListener","map","unsubscribeAfterApply","off","makeUnsubscribe","host","Object","assign","injectEventizeApi","value","defineProperty","configurable","defineHiddenPropertyRO","eventizedObj","on","filter","retain","inject","extend","create","eventizer","is","PRIO_C","PRIO_DEFAULT"],"mappings":"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"}